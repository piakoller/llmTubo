# utils_eval.py
import json
import os
import pandas as pd # For reading Excel
from datetime import datetime
import logging

logger = logging.getLogger(__name__)
# BasicConfig setup for standalone use or if not configured by app_eval.py's main logger
if not logger.hasHandlers():
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# Path to the Excel file generated by aggregate_for_expert_review.py
AGGREGATED_EXCEL_INPUT_FILE = "/home/pia/projects/llmTubo/tuboEval/expert_review_sheets/expert_evaluation_sheet_v2.xlsx"

# Directory where the individual evaluation JSONs (filled by experts) will be saved
EVALUATION_RESULTS_SAVE_DIR = "/home/pia/projects/llmTubo/tuboEval/evaluations_completed/"

try:
    os.makedirs(EVALUATION_RESULTS_SAVE_DIR, exist_ok=True)
except OSError as e:
    logger.error(f"Could not create directory for saving evaluations {EVALUATION_RESULTS_SAVE_DIR}: {e}")

_df_all_cases_for_eval_cache: pd.DataFrame | None = None

def load_cases_from_aggregated_excel() -> pd.DataFrame | None:
    global _df_all_cases_for_eval_cache
    if _df_all_cases_for_eval_cache is not None:
        # logger.debug("Returning cached DataFrame of cases for evaluation.") # Too verbose for INFO
        return _df_all_cases_for_eval_cache
    
    if not os.path.exists(AGGREGATED_EXCEL_INPUT_FILE):
        logger.error(f"Aggregated Excel input file not found: {AGGREGATED_EXCEL_INPUT_FILE}")
        return None
    try:
        logger.info(f"Loading cases for evaluation from: {AGGREGATED_EXCEL_INPUT_FILE}")
        df = pd.read_excel(AGGREGATED_EXCEL_INPUT_FILE, sheet_name="Expert Evaluation", dtype={"Patient ID": str})
        df = df.fillna('') 
        
        if "Patient ID" not in df.columns:
            logger.error("'Patient ID' column not found in the 'Expert Evaluation' sheet.")
            return None
        
        _df_all_cases_for_eval_cache = df
        logger.info(f"Successfully loaded {len(df)} patient cases for evaluation.")
        return df
    except Exception as e:
        logger.error(f"Error loading cases from Excel {AGGREGATED_EXCEL_INPUT_FILE}: {e}", exc_info=True)
        return None

def get_displayable_patient_case_options() -> dict[str, str]:
    df = load_cases_from_aggregated_excel()
    options = {}
    if df is not None and "Patient ID" in df.columns:
        for index, row in df.iterrows():
            patient_id = str(row["Patient ID"])
            # Example for more descriptive option:
            # source_file_example = row.get('Source File (Example)', 'N/A') # If you added this col in aggregate script
            # options[patient_id] = f"{patient_id} (Source: {source_file_example})"
            options[patient_id] = patient_id # Simple display for now
    if not options:
        logger.warning("No patient IDs found or DataFrame could not be loaded for selectbox options.")
    return options

def get_full_case_data_for_patient_id(patient_id: str) -> pd.Series | None:
    df = load_cases_from_aggregated_excel()
    if df is not None and "Patient ID" in df.columns:
        patient_rows = df[df["Patient ID"].astype(str) == str(patient_id)]
        if not patient_rows.empty:
            return patient_rows.iloc[0]
        else:
            logger.warning(f"Patient ID '{patient_id}' not found in the loaded Excel data.")
    return None

def save_expert_evaluation_form_data(patient_id: str, evaluation_payload: dict, expert_name: str) -> tuple[bool, str | None]:
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    safe_patient_id = patient_id.replace('/', '_').replace('\\', '_')
    safe_expert_name = expert_name.replace(' ', '_').replace('/', '_').replace('\\', '_')
    eval_filename = f"eval_result_{safe_patient_id}_{safe_expert_name}_{timestamp}.json"
    filepath = os.path.join(EVALUATION_RESULTS_SAVE_DIR, eval_filename)
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(evaluation_payload, f, indent=2, ensure_ascii=False)
        logger.info(f"Expert evaluation for patient {patient_id} by {expert_name} saved to: {filepath}")
        return True, eval_filename
    except Exception as e:
        logger.error(f"Error saving expert evaluation form data for {patient_id}: {e}", exc_info=True)
        return False, None